// - Implementation
// - Namespace access syntax
// - Sugar for module signature and module implementation
//   - `module type` etc in OCaml

// Namespace

// TODO: restrict to valid identfiers strings (a-z, A-Z, 0-9)
type Id {
  new(id: String)
}

Id.cmp(a: Id, b: Id): Cmp
  open a
  open b
  String.cmp(a.id, b.id)

Namespace<T: Type>: Type
  BBT<Id, T>

Namespace.new<T: Type>: Namespace<T>
  BBT.tip!!

Namespace.insert<T: Type>(id: Id, val: T, ns: Namespace<T>): Namespace<T>
  BBT.insert<Id, T>(Id.cmp)(id, val, ns)

// Modules

ModuleSig: Type
  Namespace<Type>

ModuleSig.empty: ModuleSig
  Namespace.new<Type>
  
ModuleSig.add(id: Id, t: Type, sig: ModuleSig): ModuleSig
  Namespace.insert<Type>(id, t, sig)

type Vector (A: Type) ~ (len: Nat) {
  nil                                          ~ (len = Nat.zero)
  cons(len: Nat, head: A, tail: Vector(A,len)) ~ (len = Nat.succ(len))
}

type KModule ~ (sig: ModuleSig) {
  empty
    ~ (sig = ModuleSig.empty)
  add<sig: ModuleSig>(
    T: Type,
    id: Id,
    val: T,
    mod: KModule<sig>,
  )
    ~ (sig = ModuleSig.add(id, T, sig))
}

// Example

ExampleModuleSig: ModuleSig
  def id = Id.new
  let sig = ModuleSig.empty
  //
  let sig = ModuleSig.add( id("x")   Int    )(sig)
  let sig = ModuleSig.add( id("txt") String )(sig)
  //
  sig

ExampleModule: KModule<ExampleModuleSig>
  def id = Id.new
  let mod = KModule.empty
  //
  let mod = KModule.add!( Int     id("x")    42     )(mod)
  let mod = KModule.add!( String  id("txt")  "fuba" )(mod)

  // let mod = KModule.add!( Bits    id("ops")  Bits.e )(mod)  // FAILS o/

  mod
