// - Implementation
// - Sugar for module signature and module implementation
//   - `module type` etc in OCaml
// - Namespace access syntax
//   - test with `::`

// TODO: fix map equality depending on order of insertion

// Namespaces

// TODO: restrict to valid identifier strings (a-z, A-Z, 0-9, _)
type Id {
  new(id: String)
}

Id.cmp(a: Id, b: Id): Cmp
  open a
  open b
  String.cmp(a.id, b.id)

Namespace<T: Type>: Type
  BBT<Id, T>

Namespace.new<T: Type>: Namespace<T>
  BBT.tip!!

Namespace.insert<T: Type>(id: Id, val: T, ns: Namespace<T>): Namespace<T>
  BBT.insert<Id, T>(Id.cmp)(id, val, ns)

// Generic Signature
// Id => Type

Sig: Type
  Namespace<Type>

Sig.empty: Sig
  Namespace.new<Type>

Sig.add(id: Id, t: Type, sig: Sig): Sig
  Namespace.insert<Type>(id, t, sig)

// Modules

type KModule ~ (sig: Sig) {
  empty
    ~ (sig = Sig.empty)
  add<sig: Sig>(
    id: Id,
    T: Type,
    val: T,
    mod: KModule<sig>,
  )
    ~ (sig = Sig.add(id, T, sig))
}

// Example

ExampleModuleSig: Sig
  def id = Id.new
  let sig = Sig.empty
  //
  let sig = Sig.add( id("x")   Nat    )(sig)
  let sig = Sig.add( id("txt") String )(sig)
  //
  sig

ExampleModule: KModule<ExampleModuleSig>
  def id = Id.new
  let mod = KModule.empty
  //
  let mod = KModule.add!( id("x")    Nat     42     )(mod)
  let mod = KModule.add!( id("txt")  String  "fuba" )(mod)

  // let mod = KModule.add!( Bits    id("ops")  Bits.e )(mod)  // FAILS o/

  mod
